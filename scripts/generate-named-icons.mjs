import { readFile, writeFile, access } from 'node:fs/promises';
import path from 'node:path';

const root = process.cwd();
const args = new Set(process.argv.slice(2));
const checkOnly = args.has('--check');
const componentsBarrel = path.join(root, 'src', 'icons', 'components.ts');
const namedOut = path.join(root, 'src', 'icons', 'named.ts');

function parseExportNames(src) {
  const names = [];
  const re = /export\s*\{\s*([^}]+)\s*}\s*from\s*["']\.\/components\/[A-Za-z0-9_\-]+\.js["'];?/g;
  let m;
  while ((m = re.exec(src))) {
    const inner = m[1];
    // inner could be "Name as Alias" or multiple, but our file uses single names per line
    const parts = inner.split(',').map(s => s.trim()).filter(Boolean);
    for (const p of parts) {
      // support "Name as Alias"
      const aliasMatch = p.match(/^(\w+)\s+as\s+(\w+)$/);
      if (aliasMatch) {
        names.push(aliasMatch[2]);
      } else {
        names.push(p);
      }
    }
  }
  // de-dup and sort for stable output
  return Array.from(new Set(names)).sort();
}

async function run() {
  const src = await readFile(componentsBarrel, 'utf8');
  const names = parseExportNames(src);
  const header = `import { wrapIcon } from "./wrapIcon.js";\nimport * as Paths from "./components.js";\n\n`;
  const body = names.map((n) => `export const ${n} = wrapIcon(Paths.${n});`).join('\n') + '\n';
  const content = header + '// Auto-generated by scripts/generate-named-icons.mjs\n' + body;
  let current = '';
  try {
    await access(namedOut);
    current = await readFile(namedOut, 'utf8');
  } catch {}
  // Order-tolerant check when --check is used
  if (checkOnly) {
    const expectedLines = body
      .split(/\r?\n/)
      .map((l) => l.trim())
      .filter(Boolean)
      .filter((l) => l.startsWith('export const '));
    const currentLines = current
      .split(/\r?\n/)
      .map((l) => l.trim())
      .filter(Boolean)
      .filter((l) => l.startsWith('export const '));
    const missing = expectedLines.filter((l) => !currentLines.includes(l));
    const extra = currentLines.filter((l) => !expectedLines.includes(l));
    if (missing.length === 0 && extra.length === 0) {
      process.stdout.write('No changes in wrapped icons.\n');
      return;
    }
    process.stdout.write('Named icons check FAILED: src/icons/named.ts is out of date.\n');
    if (missing.length) {
      process.stdout.write('Missing exports:\n');
      missing.forEach((l) => process.stdout.write('  ' + l + '\n'));
    }
    if (extra.length) {
      process.stdout.write('Unexpected exports present:\n');
      extra.forEach((l) => process.stdout.write('  ' + l + '\n'));
    }
    process.stdout.write('Run: npm run icons:named:write\n');
    process.exit(1);
  }

  // Write canonical content in non-check mode
  if (current !== content) {
    await writeFile(namedOut, content, 'utf8');
    process.stdout.write(`Wrote ${names.length} wrapped icons to src/icons/named.ts\n`);
  } else {
    if (checkOnly) {
      process.stdout.write('Named icons check PASSED: src/icons/named.ts is up to date.\n');
      process.exit(0);
    }
    process.stdout.write('No changes in wrapped icons.\n');
  }
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
